package com.teamscale.report.jacoco

import com.teamscale.report.EDuplicateClassFileBehavior
import com.teamscale.report.jacoco.dump.Dump
import com.teamscale.report.util.ClasspathWildcardIncludeFilter
import com.teamscale.report.util.ILogger
import com.teamscale.test.TestDataBase
import org.assertj.core.api.Assertions
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.assertThatThrownBy
import org.jacoco.core.data.ExecutionData
import org.jacoco.core.data.ExecutionDataStore
import org.jacoco.core.data.SessionInfo
import org.jacoco.core.internal.data.CRC64
import org.junit.jupiter.api.Test
import org.mockito.Mockito
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.IOException
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths

/** Tests report generation with and without duplicate classes.  */
class JaCoCoXmlReportGeneratorTest : TestDataBase() {
	/** Ensures that the normal case (no duplicated classes) runs without exceptions.  */
	@Test
	fun testNormalCaseThrowsNoException() {
		try {
			runGenerator("no-duplicates", EDuplicateClassFileBehavior.FAIL)
		} catch (e: EmptyReportException) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	/** Ensures that two identical duplicate classes do not cause problems.  */
	@Test
	fun testIdenticalClassesShouldNotThrowException() {
		try {
			runGenerator("identical-duplicate-classes", EDuplicateClassFileBehavior.FAIL)
		} catch (e: EmptyReportException) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	/**
	 * Ensures that two non-identical, duplicate classes cause an exception to be thrown.
	 */
	@Test
	fun testDifferentClassesWithTheSameNameShouldThrowException() {
		assertThatThrownBy {
			runGenerator(
				"different-duplicate-classes",
				EDuplicateClassFileBehavior.FAIL
			)
		}.isExactlyInstanceOf(IOException::class.java)
			.hasCauseExactlyInstanceOf(IllegalStateException::class.java)
	}

	/**
	 * Ensures that two non-identical, duplicate classes do not cause an exception to be thrown if the ignore-duplicates
	 * flag is set.
	 */
	@Test
	fun testDifferentClassesWithTheSameNameShouldNotThrowExceptionIfFlagIsSet() {
		try {
			runGenerator("different-duplicate-classes", EDuplicateClassFileBehavior.IGNORE)
		} catch (e: EmptyReportException) {
			// An empty report exception is thrown here because we did not configure the correct class IDs to match the
			// artificial coverage generated by createDummyDump to the actual class file. Since we are only testing for
			// IllegalStateExceptions resulting from duplicated, non-identical class files, and don't care about empty
			// reports here. Therefore we catch this exception to avoid letting the test fail because of it.
		}
	}

	@Test
	fun testEmptyCoverageFileThrowsException() {
		val testFolderName = "empty-report-handling"
		val classId = calculateClassId(testFolderName, "TestClass.class")
		assertThatThrownBy {
			runGenerator(
				testFolderName,
				EDuplicateClassFileBehavior.IGNORE,
				false,
				ClasspathWildcardIncludeFilter("some.package.*", null),
				createDummyDump(classId)
			)
		}.isExactlyInstanceOf(EmptyReportException::class.java)
	}

	@Test
	@Throws(IOException::class, EmptyReportException::class)
	fun testNonEmptyCoverageFileDoesNotThrowException() {
		val testFolderName = "empty-report-handling"
		val classId = calculateClassId(testFolderName, "TestClass.class")
		runGenerator(
			testFolderName, EDuplicateClassFileBehavior.IGNORE, false,
			ClasspathWildcardIncludeFilter("*", null), createDummyDump(classId)
		)
	}

	/** Ensures that uncovered classes are removed from the report if ignore-uncovered-classes is set.  */
	@Test
	fun testShrinking() {
		val testFolderName = "ignore-uncovered-classes"
		val classId = calculateClassId(testFolderName, "TestClass.class")
		val stream = ByteArrayOutputStream()

		runGenerator(
			testFolderName, EDuplicateClassFileBehavior.FAIL, true,
			ClasspathWildcardIncludeFilter("*", null),
			createDummyDump(classId)
		).copy(stream) // ToDo: copy has Unit as return type so why does it throw "Unused result of data class copy"

		val xmlString = stream.toString(StandardCharsets.UTF_8.name())
		assertThat(xmlString).contains("TestClass")
		assertThat(xmlString).doesNotContain("TestClassTwo")
		assertThat(xmlString).doesNotContain("ITestInterface")
	}

	/** Ensures that uncovered classes are contained in the report if ignore-uncovered-classes is not set.  */
	@Test
	fun testNonShrinking() {
		val testFolderName = "ignore-uncovered-classes"
		val classId = calculateClassId(testFolderName, "TestClass.class")
		val stream = ByteArrayOutputStream()

		runGenerator(
			testFolderName, EDuplicateClassFileBehavior.FAIL, false,
			ClasspathWildcardIncludeFilter("*", null),
			createDummyDump(classId)
		).copy(stream)

		val xmlString = stream.toString(StandardCharsets.UTF_8.name())
		assertThat(xmlString).contains("TestClassTwo")
	}

	@Throws(IOException::class)
	private fun calculateClassId(testFolderName: String, classFileName: String): Long {
		val classFile = useTestFile(testFolderName + File.separator + classFileName)
		return CRC64.classId(Files.readAllBytes(classFile.toPath()))
	}

	/** Runs the report generator with default values and without ignoring uncovered classes.  */
	@Throws(IOException::class, EmptyReportException::class)
	private fun runGenerator(
		testDataFolder: String,
		duplicateClassFileBehavior: EDuplicateClassFileBehavior,
		ignoreUncoveredClasses: Boolean = false,
		filter: ClasspathWildcardIncludeFilter = ClasspathWildcardIncludeFilter(null, null),
		dump: Dump = createDummyDump()
	): CoverageFile {
		val classFileFolder = useTestFile(testDataFolder)
		val currentTime = System.currentTimeMillis()
		val outputFilePath = "test-coverage-$currentTime.xml"
		return JaCoCoXmlReportGenerator(
			listOf(classFileFolder),
			filter,
			duplicateClassFileBehavior,
			ignoreUncoveredClasses,
			Mockito.mock()
		).convert(dump, Paths.get(outputFilePath).toFile())
	}

	companion object {
		/**
		 * Creates a fake dump with the specified class ID. The class ID can currently be calculated with [org.jacoco.core.internal.data.CRC64.classId].
		 * This might change in the future, as it's considered an [implementation detail of JaCoCo](https://www.jacoco.org/jacoco/trunk/doc/classids.html))
		 */
		private fun createDummyDump(classId: Long = 123): Dump {
			val store = ExecutionDataStore()
			store.put(ExecutionData(classId, "TestClass", booleanArrayOf(true, true, true)))
			val info = SessionInfo("session-id", 124L, 125L)
			return Dump(info, store)
		}
	}
}
