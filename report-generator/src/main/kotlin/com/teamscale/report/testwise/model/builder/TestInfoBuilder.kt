package com.teamscale.report.testwise.model.builder

import com.teamscale.client.TestDetails
import com.teamscale.report.testwise.model.ETestExecutionResult
import com.teamscale.report.testwise.model.TestExecution
import com.teamscale.report.testwise.model.TestInfo

/** Generic container of all information about a specific test including details, execution info and coverage.  */
class TestInfoBuilder
/** Constructor.  */ /* package */(
	/** Unique name of the test case by using a path like hierarchical description, which can be shown in the UI.  */
	val uniformPath: String
) {
	/** @see .uniformPath
	 */

	/**
	 * Path to the source of the method. Will be equal to uniformPath in most cases, but e.g. @Test methods in a base
	 * class will have the sourcePath pointing to the base class which contains the actual implementation whereas
	 * uniformPath will contain the the class name of the most specific subclass, from where it was actually executed.
	 */
	private var sourcePath: String? = null

	/**
	 * Some kind of content to tell whether the test specification has changed. Can be revision number or hash over the
	 * specification or similar.
	 */
	private var content: String? = null

	/** Duration of the execution in milliseconds.  */
	private var durationSeconds: Double? = null

	/** The actual execution result state.  */
	private var result: ETestExecutionResult? = null

	/**
	 * Optional message given for test failures (normally contains a stack trace). May be `null`.
	 */
	private var message: String? = null

	/** Coverage generated by this test.  */
	private var coverage: TestCoverageBuilder? = null

	val isEmpty: Boolean
		/** Returns true if there is no coverage for the test yet.  */
		get() = coverage?.isEmpty == true

	/** Sets the test details fields.  */
	fun setDetails(details: TestDetails?) {
		if (details != null) {
			sourcePath = details.sourcePath
			content = details.content
		}
	}

	/** Sets the test execution fields.  */
	fun setExecution(execution: TestExecution?) {
		if (execution != null) {
			durationSeconds = execution.durationSeconds
			result = execution.result
			message = execution.message
		}
	}

	/** @see .coverage
	 */
	fun setCoverage(coverage: TestCoverageBuilder?) {
		this.coverage = coverage
	}

	/** Builds a [TestInfo] object of the data in this container.  */
	fun build(): TestInfo {
		val testInfo = TestInfo(
			uniformPath, sourcePath, content, durationSeconds, result, message
		)
		coverage?.let {
			testInfo.paths.addAll(it.paths)
		}
		return testInfo
	}
}
