package com.teamscale.reporting.compact

import com.teamscale.report.EDuplicateClassFileBehavior
import com.teamscale.report.compact.CompactCoverageReportGenerator
import com.teamscale.report.jacoco.EmptyReportException
import com.teamscale.report.util.ClasspathWildcardIncludeFilter
import com.teamscale.reporting.compact.internal.DefaultCompactCoverageTaskReportContainer
import com.teamscale.utils.wrapInILogger
import groovy.lang.Closure
import org.gradle.api.Action
import org.gradle.api.DefaultTask
import org.gradle.api.Task
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.reporting.Reporting
import org.gradle.api.reporting.ReportingExtension
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.findByType
import org.gradle.kotlin.dsl.getByType
import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
import org.gradle.util.internal.ClosureBackedAction
import javax.inject.Inject


/**
 * Task which generates a
 * [Teamscale Compact Coverage](https://docs.teamscale.com/reference/upload-formats-and-samples/teamscale-compact-coverage/)
 * report from binary JaCoCo coverage data.
 */
@CacheableTask
@Suppress("MemberVisibilityCanBePrivate")
abstract class CompactCoverageReport @Inject constructor(objectFactory: ObjectFactory) : DefaultTask(),
	Reporting<CompactCoverageTaskReportContainer> {

	@get:PathSensitive(PathSensitivity.NONE)
	@get:InputFiles
	abstract val executionData: ConfigurableFileCollection

	@get:Classpath
	abstract val classDirectories: ConfigurableFileCollection

	private val reports: CompactCoverageTaskReportContainer

	init {
		group = "Teamscale"
		description = "Executes the impacted tests and collects coverage per test case"
		reports = objectFactory.newInstance(DefaultCompactCoverageTaskReportContainer::class.java)


		val reporting = project.extensions.getByType<ReportingExtension>()
		val reportDirectory: DirectoryProperty = objectFactory.directoryProperty().convention(
			reporting.baseDirectory.dir("compact-coverage")
		)

		reports.compactCoverage.required.convention(true)
		reports.compactCoverage.outputLocation.convention(reportDirectory.file("${name}/compact-coverage.json"))

		onlyIf("Any of the execution data files exists") { executionData.files.any { it.exists() } }
	}

	@TaskAction
	fun generateReport() {
		if (!reports.compactCoverage.required.get()) {
			return
		}
		logger.info("Generating compact coverage report...")
		logger.debug("Class files: {}", classDirectories.files)
		logger.debug("Execution data files: {}", executionData.files)
		val generator = CompactCoverageReportGenerator(
			classDirectories.files.filter { it.exists() },
			ClasspathWildcardIncludeFilter(null, null),
			EDuplicateClassFileBehavior.IGNORE,
			logger.wrapInILogger()
		)

		try {
			generator.convertExecFilesToReport(executionData.files, reports.compactCoverage.outputLocation.get().asFile)
		} catch (e: EmptyReportException) {
			logger.warn("Converted report was empty.")
		}
	}


	/**
	 * Adds execution data files to be used during coverage analysis.
	 *
	 * @param files one or more files to add
	 */
	fun executionData(vararg files: Any) {
		executionData.from(*files)
	}

	/**
	 * Adds execution data generated by a task to the list of those used during coverage analysis. Only tasks with a [JacocoTaskExtension] will be included; all others will be ignored.
	 *
	 * @param tasks one or more tasks to add
	 */
	fun executionData(vararg tasks: Task) {
		for (task in tasks) {
			val extension = task.extensions.findByType<JacocoTaskExtension>()
			if (extension != null) {
				executionData(task.project.provider { extension.destinationFile })
				mustRunAfter(task)
			}
		}
	}

	/**
	 * Adds a source set to the list to be reported on. The output of this source set will be used as classes to include in the report. The source for this source set will be used for any classes
	 * included in the report.
	 *
	 * @param sourceSets one or more source sets to report on
	 */
	fun sourceSets(vararg sourceSets: SourceSet) {
		for (sourceSet in sourceSets) {
			classDirectories.from(sourceSet.output)
		}
	}

	/**
	 * The reports that this task potentially produces.
	 *
	 * @return The reports that this task potentially produces
	 */
	@Nested
	override fun getReports(): CompactCoverageTaskReportContainer {
		return reports
	}

	/**
	 * Configures the reports that this task potentially produces.
	 *
	 * @param closure The configuration
	 * @return The reports that this task potentially produces
	 */
	override fun reports(closure: Closure<*>): CompactCoverageTaskReportContainer {
		return reports(ClosureBackedAction(closure))
	}

	/**
	 * Configures the reports that this task potentially produces.
	 *
	 * @param configureAction The configuration
	 * @return The reports that this task potentially produces
	 */
	override fun reports(configureAction: Action<in CompactCoverageTaskReportContainer>): CompactCoverageTaskReportContainer {
		configureAction.execute(reports)
		return reports
	}
}


