package com.teamscale

import com.teamscale.internal.DefaultCompactCoverageTaskReports
import com.teamscale.report.EDuplicateClassFileBehavior
import com.teamscale.report.compact.CompactCoverageReportGenerator
import com.teamscale.report.jacoco.EmptyReportException
import com.teamscale.report.util.ClasspathWildcardIncludeFilter
import groovy.lang.Closure
import org.gradle.api.Action
import org.gradle.api.DefaultTask
import org.gradle.api.Task
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.model.ObjectFactory
import org.gradle.api.reporting.Report
import org.gradle.api.reporting.ReportContainer
import org.gradle.api.reporting.Reporting
import org.gradle.api.reporting.SingleFileReport
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.findByType
import org.gradle.testing.jacoco.plugins.JacocoTaskExtension
import org.gradle.util.internal.ClosureBackedAction
import javax.inject.Inject


/** Task which runs the impacted tests. */
@Suppress("MemberVisibilityCanBePrivate")
abstract class CompactCoverageReport @Inject constructor(objects: ObjectFactory) : DefaultTask(),
	Reporting<CompactCoverageTaskReports> {

	@get:PathSensitive(PathSensitivity.NONE)
	@get:InputFiles
	abstract val executionData: ConfigurableFileCollection

	@get:Classpath
	abstract val classDirectories: ConfigurableFileCollection

	private val reports: CompactCoverageTaskReports

	init {
		group = "Teamscale"
		description = "Executes the impacted tests and collects coverage per test case"
		reports = objects.newInstance(DefaultCompactCoverageTaskReports::class.java)
		reports.compactCoverage.required.convention(true)
		reports.compactCoverage.outputLocation.convention(project.layout.buildDirectory.file("reports/compact-coverage/${name}/compact-coverage.json"))

		onlyIf("Any of the execution data files exists") { executionData.any { it.exists() } }
	}

	@TaskAction
	fun generateReport() {
		if (!reports.compactCoverage.required.get()) {
			return
		}
		logger.info("Generating compact coverage report...")
		val generator = CompactCoverageReportGenerator(
			classDirectories.files.filter { it.exists() },
			ClasspathWildcardIncludeFilter(null, null),
			EDuplicateClassFileBehavior.IGNORE,
			logger.wrapInILogger()
		)

		try {
			generator.convertExecFilesToReport(executionData.files, reports.compactCoverage.outputLocation.get().asFile)
		} catch (e: EmptyReportException) {
			logger.warn("Converted report was empty.", e)
		}
	}


	/**
	 * Adds execution data files to be used during coverage analysis.
	 *
	 * @param files one or more files to add
	 */
	fun executionData(vararg files: Any) {
		executionData.from(*files)
	}

	/**
	 * Adds execution data generated by a task to the list of those used during coverage analysis. Only tasks with a [JacocoTaskExtension] will be included; all others will be ignored.
	 *
	 * @param tasks one or more tasks to add
	 */
	fun executionData(vararg tasks: Task) {
		for (task in tasks) {
			val extension = task.extensions.findByType<JacocoTaskExtension>()
			if (extension != null) {
				executionData({ extension.destinationFile })
				mustRunAfter(task)
			}
		}
	}

	/**
	 * Adds a source set to the list to be reported on. The output of this source set will be used as classes to include in the report. The source for this source set will be used for any classes
	 * included in the report.
	 *
	 * @param sourceSets one or more source sets to report on
	 */
	fun sourceSets(vararg sourceSets: SourceSet) {
		for (sourceSet in sourceSets) {
			classDirectories.from(sourceSet.output)
		}
	}

	/**
	 * The reports that this task potentially produces.
	 *
	 * @return The reports that this task potentially produces
	 */
	@Nested
	override fun getReports(): CompactCoverageTaskReports {
		return reports
	}

	/**
	 * Configures the reports that this task potentially produces.
	 *
	 * @param closure The configuration
	 * @return The reports that this task potentially produces
	 */
	override fun reports(closure: Closure<*>): CompactCoverageTaskReports {
		return reports(ClosureBackedAction(closure))
	}

	/**
	 * Configures the reports that this task potentially produces.
	 *
	 * @param configureAction The configuration
	 * @return The reports that this task potentially produces
	 */
	override fun reports(configureAction: Action<in CompactCoverageTaskReports?>): CompactCoverageTaskReports {
		configureAction.execute(reports)
		return reports
	}
}


/**
 * The reports produced by the [CompactCoverageReport] task.
 */
interface CompactCoverageTaskReports : ReportContainer<Report> {
	@get:Internal
	val compactCoverage: SingleFileReport
}
