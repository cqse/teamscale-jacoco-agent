package eu.cqse.teamscale.jacoco.recorder.report;

import org.jacoco.core.analysis.Analyzer;
import org.jacoco.core.analysis.CoverageBuilder;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.tools.ExecFileLoader;
import org.jacoco.report.DirectorySourceFileLocator;
import org.jacoco.report.IReportVisitor;

import java.io.*;
import java.util.HashSet;

/**
 * This example creates a XML report for eclipse like projects based on a single
 * execution data store called jacoco.exec. The report contains no grouping
 * information.
 * <p>
 * The class files under test must be compiled with debug information, otherwise
 * source highlighting will not work.
 */
public class XMLReportGenerator {

	private final String title;

	private final byte[] executionData;
	private final File classesDirectory;
	private final File sourceDirectory;

	private ExecFileLoader execFileLoader;

	/**
	 * Create a new generator based for the given project.
	 * 
	 * @param projectDirectory
	 *            Root directory that contains the projects source and class
	 *            files.
	 * @param executionData
	 *            The *.exec file generated by jacoco.
	 */
	public XMLReportGenerator(final File projectDirectory, byte[] executionData) {
		this.title = projectDirectory.getName();
		this.executionData = executionData;
		this.classesDirectory = projectDirectory;
		this.sourceDirectory = projectDirectory;
	}

	/**
	 * Create the report.
	 *
	 * @throws IOException
	 */
	public byte[] create() throws IOException {
		// Read the jacoco.exec file. Multiple data files could be merged
		// at this point
		loadExecutionData();

		// Run the structure analyzer on a single class folder to build up
		// the coverage model. The process would be similar if your classes
		// were in a jar file. Typically you would create a bundle for each
		// class folder and each jar you want in your report. If you have
		// more than one bundle you will need to add a grouping node to your
		// report
		final IBundleCoverage bundleCoverage = analyzeStructure();

		return createReport(bundleCoverage);
	}

	private void loadExecutionData() throws IOException {
		execFileLoader = new ExecFileLoader();
		execFileLoader.load(new ByteArrayInputStream(executionData));
	}

	private byte[] createReport(final IBundleCoverage bundleCoverage) throws IOException {
		ByteArrayOutputStream output = new ByteArrayOutputStream();
		// Create a concrete report visitor based on some supplied
		// configuration. In this case we use the defaults
		final FilteringXMLFormatter xmlFormatter = new FilteringXMLFormatter();
		final IReportVisitor visitor = xmlFormatter.createVisitor(output);

		// Initialize the report with all of the execution and session
		// information. At this point the report doesn't know about the
		// structure of the report being created
		visitor.visitInfo(execFileLoader.getSessionInfoStore().getInfos(),
				execFileLoader.getExecutionDataStore().getContents());

		// Populate the report structure with the bundle coverage information.
		// Call visitGroup if you need groups in your report.
		visitor.visitBundle(bundleCoverage, new DirectorySourceFileLocator(sourceDirectory, "utf-8", 4));

		// Signal end of structure information to allow report to write all
		// information out
		visitor.visitEnd();

		return output.toByteArray();
	}

	private HashSet<String> includedClassFiles = new HashSet<>();

	private IBundleCoverage analyzeStructure() throws IOException {
		final CoverageBuilder coverageBuilder = new CoverageBuilder();
		final Analyzer analyzer = new Analyzer(execFileLoader.getExecutionDataStore(), coverageBuilder) {
			@Override
			public int analyzeAll(final InputStream input, final String location) throws IOException {
				if (!location.endsWith(".class")) {
					return 0;
				}
				File file = new File(location);

				if (location.contains("test-data") || includedClassFiles.contains(file.getName())) {
					// System.out.println("Ignoring: " + location);
					return 0;
				}
				includedClassFiles.add(file.getName());

                return super.analyzeAll(input, location);
			}
		};

		analyzer.analyzeAll(classesDirectory);

		return coverageBuilder.getBundle(title);
	}

}